//
//  lib.tools.ts
//
// Generated by Poll Castillo on 15/02/2023.
import { currentTime } from "./UserLoggedInfo"
import { getEntitiesData, getUserInfo } from "./endpoints.js"
import { Data, InterfaceElement, InterfaceElementCollection } from "./types.js"

//
export const inputObserver = (): void => {
    const inputs = <NodeListOf<Element>>document.querySelectorAll('input')
    inputs.forEach((input: any) => {
        input.addEventListener("keyup", (e: any): void => {
            if (input.value == "" || input.value == " ")
                input.classList.remove('input_filled'),
                    input.value = ""
            else
                input.classList.add('input_filled')
        })
    })
}

export const inputSelect = async (entity: string, selectId: string, currentStatus?: string): Promise<void> => {
    const data = await getEntitiesData(entity)
    const state = await currentStatus
    const select: InterfaceElement = document.querySelector(`#${selectId}`)
    const inputParent = select.parentNode
    const optionsContent = inputParent.querySelector('#input-options')
    const optionsContainer: InterfaceElement = document.createElement('div')
    optionsContainer.classList.add('input_options_container')

    optionsContent.appendChild(optionsContainer)

    for (let i = 0; i < data.length; i++) {
        const inputOption: InterfaceElement = document.createElement('div')
        select.setAttribute('data-optionid', data[0].id)
        select.setAttribute('value', data[0].name)
        inputOption.classList.add('input_option')
        inputOption.setAttribute('id', data[i].id)
        let nameData: Data = data[i].name
        if (nameData === 'Enabled') {
            nameData = 'Activo'
        } else if (nameData === 'Disabled') {
            nameData = 'Inactivo'
        }
        inputOption.innerHTML = nameData

        optionsContainer.appendChild(inputOption)
    }
    const options: InterfaceElement = optionsContainer.querySelectorAll('.input_option')

    if (state === "Enabled") {
        select.value = "Activo"
        select.setAttribute('data-optionid', '60885987-1b61-4247-94c7-dff348347f93')
    } else if (state === 'Disabled') {
        select.value = "Inactivo"
        select.setAttribute('data-optionid', '225b5e5d-9bb1-469a-b2d9-ca85d53db47b')
    } else {
        select.value = data[0].name
    }

    select.addEventListener('click', (): void => {
        inputParent.classList.toggle('select_active')
    })

    options.forEach((option: any) => {
        option.addEventListener('click', (): void => {
            select.value = option.innerText
            select.removeAttribute('data-optionid')
            select.setAttribute('data-optionid', option.getAttribute('id'))
            inputParent.classList.remove('select_active')
        })
    })
}

export class FixStatusElement {
    public fix(element: any): void {
        const elementTextValue = element.innerText
        if (elementTextValue === "Enabled")
            elementTextValue.innerText = 'Activo',
                elementTextValue.toUpperCase()
        else
            elementTextValue.toUpperCase()
    }
}

export class FixStatusInputElement {
    public fix(inputId: string): void {
        const inputs = <NodeListOf<Element>>document.querySelectorAll(`#${inputId}`)
        inputs.forEach((input: any): void => {
            if (input.value === 'Enabled')
                input.value = 'Activo'.toUpperCase()
            else if (input.value == 'Disabled')
                input.value = 'Inactivo'.toUpperCase()
        })
    }
}

export const drawTagsIntoTables = (): void => {
    const tags: HTMLElement | any = document.querySelectorAll('.tag span')
    tags.forEach((tag: any): void => {
        let text = tag.innerText
        if (text === "Enabled" ||
            text === "enabled" ||
            text === "ENABLED" ||
            text === "Activo" ||
            text === "ACTIVO") {
            tag.innerText = "Activo"
            tag.classList.add("tag_green")
        }
        else if (text === "Disabled" ||
            text === "disabled" ||
            text === "DISABLED" ||
            text === "Inactivo" ||
            text === "INACTIVO") {
            tag.innerText = "Inactivo"
            tag.classList.add("tag_gray")
        } else if (text === "Pendiente" ||
            text === "pendiente" ||
            text === "PENDIENTE") {
            tag.classList.add("tag_yellow")
        } else {
            tag.classList.add('tag_gray')
        }
    })
}

export class CloseDialog {
    public x(container?: any) {
        container.style.display = 'none'
        // const dialog: InterfaceElement = container.firstElementChild
        // dialog.remove()
    }
}

// SIDEBAR RENDERING TOOLS
export const renderRightSidebar = (UIFragment: InterfaceElement) => {
    const dialogContainer: InterfaceElement = document.getElementById('entity-editor-container')

    dialogContainer.innerHTML = ''
    dialogContainer.style.display = 'flex'
    dialogContainer.innerHTML = UIFragment
}

export const fixDate = () => {
    const arrayDates: InterfaceElementCollection = document.querySelectorAll('#table-date')
    arrayDates.forEach((date: InterfaceElement) => {
        const dateP1 = date.innerText.split('-')
        const dateP2 = dateP1[2].split('T')
        const dateP3 = dateP2[1].split(':')

        const YearDate = dateP1[0]
        const MonthDate = dateP1[1]
        const DayDate = dateP2[0]

        const Hours = dateP3[0]
        const Minutes = dateP3[1]
        const Seconds = dateP3[2]

        const DT = YearDate + ' ' + MonthDate + ' ' + DayDate
        const Time = Hours + ':' + Minutes + ':' + Seconds.slice(0, 2)

        date.innerText = DT + ' ' + Time
    })

}

export class filterDataByHeaderType {
    private readonly datatable: InterfaceElement = document.getElementById('datatable')

    public filter = (): void => {

        this.datatable.onclick = (e: any) => {
            if (e.target.tagName != "SPAN") return
            let span = e.target
            let th = e.target.parentNode

            const THead = this.datatable.querySelectorAll('tr th span')
            THead.forEach((header: InterfaceElement) => {
                header.classList.remove('datatable_header_selected')
            })

            e.target.classList.add('datatable_header_selected')
            this.sortGrid(th.cellIndex, span.dataset.type)
        }
    }

    private sortGrid = (colNum: number, type: string): void => {
        let tbody: any = this.datatable.querySelector('tbody')
        let rowsArray = Array.from(tbody.rows)
        let compare: any

        switch (type) {
            case 'name':
                compare = (rowA: any, rowB: any) => {
                    return rowA.cells[colNum].innerHTML >
                        rowB.cells[colNum].innerHTML ? 1 : -1
                }
                break
            case 'id':
                compare = (rowA: any, rowB: any) => {
                    return rowA.cells[colNum].innerHTML >
                        rowB.cells[colNum].innerHTML ? 1 : -1
                }
                break
            case 'status':
                compare = (rowA: any, rowB: any) => {
                    return rowA.cells[colNum].innerHTML >
                        rowB.cells[colNum].innerHTML ? 1 : -1
                }
                break
            case 'citadel':
                compare = (rowA: any, rowB: any) => {
                    return rowA.cells[colNum].innerHTML >
                        rowB.cells[colNum].innerHTML ? 1 : -1
                }
                break
        }

        rowsArray.sort(compare)
        tbody.append(...rowsArray)
    }
}

export const generateCsv = async (ar: any, title: string): Promise<void> => {
    console.log('...')
    //comprobamos compatibilidad
    if (window.Blob && (window.URL || window.webkitURL)) {
        let contenido = ""
        let d: Date = new Date()
        let blob: Blob
        let reader: FileReader
        let save: any
        let clicEvent: any

        //creamos contenido del archivo
        for (let i = 0; i < ar.length; i++) {
            //construimos cabecera del csv
            if (i == 0)
                contenido += Object.keys(ar[i]).join(";") + "\n";
            //resto del contenido
            contenido += Object.keys(ar[i]).map(function (key) {
                return ar[i][key];
            }).join(";") + "\n";
        }
        //creamos el blob
        blob = new Blob(["\ufeff", contenido], { type: 'text/csv' });
        //creamos el reader
        reader = new FileReader();
        reader.onload = (e: any) => {
            //escuchamos su evento load y creamos un enlace en dom
            save = document.createElement('a');
            save.href = e.target.result;
            save.target = '_blank';
            //aquí le damos nombre al archivo
            save.download = "netliinks_" + title + "_" + d.getDate() + "_" + (d.getMonth() + 1) + "_" + d.getFullYear() + ".csv";
            try {
                //creamos un evento click
                clicEvent = new MouseEvent('click', {
                    'view': window,
                    'bubbles': true,
                    'cancelable': true
                });
            } catch (e) {
                //si llega aquí es que probablemente implemente la forma antigua de crear un enlace
                clicEvent = document.createEvent("MouseEvent");
                clicEvent.click();
            }
            //disparamos el evento
            save.dispatchEvent(clicEvent);
            //liberamos el objeto window.URL
            (window.URL || window.webkitURL).revokeObjectURL(save.href);
        }
        //leemos como url
        reader.readAsDataURL(blob);
    } else {
        //el navegador no admite esta opción
        alert("Su navegador no permite esta acción");
    }
}

export const userInfo = getUserInfo()
